#include <time.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <inttypes.h>

//#defines

#define MAX_THREAD_COUNT 9
#define MAX_TASK_COUNT 3 

//Typedefs
typedef struct{
int threadCount;
pthread_t threadId;
int threadPolicy;
int threadPri;
long processTime;
int64_t timeStamp[MAX_TASK_COUNT+1];
time_t startTime;
time_t endTime;
} ThreadArgs;


//Globals 

//Try to change this to use a single condition variable
pthread_mutex_t g_ThreadMutex [MAX_THREAD_COUNT];
pthread_cond_t g_conditionVar [MAX_THREAD_COUNT];
ThreadArgs g_ThreadArgs[MAX_THREAD_COUNT];


void InitGlobals(void)
{
// Initialize all globals
	ThreadArgs threads[MAX_THREAD_COUNT];

}

void DisplayThreadSchdAttributes( void )
{
int policy;
struct sched_param param;

pthread_getschedparam(pthread_self(), &policy, &param);

printf("DisplayThreadSchdAttributes:\n threadID = 0x%lx\n policy = %s\n priority = %d\n", 
pthread_self(),
(policy == SCHED_FIFO) ? "SCHED_FIFO" :
(policy == SCHED_RR) ? "SCHED_RR" :
(policy == SCHED_OTHER) ? "SCHED_OTHER" :
"???",
param.sched_priority);
}

void DisplayThreadStats(ThreadArgs* myThreadArg)
{
if( myThreadArg )
{
//printf("DisplayThreadArgs: Thread Id [%lx] Pri [%d] ProcTime [%ld]\n",
// myThreadArg->threadId, myThreadArg->threadPri, myThreadArg->processTime);

DisplayThreadSchdAttributes();
printf(" startTime = %s\n endTime = %s\n", ctime(&myThreadArg->startTime), ctime(&myThreadArg->endTime));
printf(" TimeStamp [%"PRId64"]\n", myThreadArg->timeStamp[0] );

for(int y=1; y<MAX_TASK_COUNT+1; y++)
{
printf(" TimeStamp [%"PRId64"] Delta [%"PRId64"]us\n", myThreadArg->timeStamp[y], 
(myThreadArg->timeStamp[y]-myThreadArg->timeStamp[y-1]));
} 

}
else
{

for(int i=0;i<MAX_THREAD_COUNT;i++)
{
//printf("DisplayThreadArgs: Thread Id [%lx] Pri [%d] ProcTime [%ld]\n",
// g_ThreadArgs[i].threadId, g_ThreadArgs[i].threadPri, g_ThreadArgs[i].processTime);

DisplayThreadSchdAttributes();
printf(" TimeStamp (task starting) [%ld]\n", g_ThreadArgs[i].timeStamp[0] );

for(int y=1; y<MAX_TASK_COUNT+1; y++)
{
printf(" TimeStamp (task completed) [%ld] Delta [%ld]\n", g_ThreadArgs[i].timeStamp[y], 
(g_ThreadArgs[i].timeStamp[y]-g_ThreadArgs[i].timeStamp[y-1]));
} 
}
} 
}

void DoProcess(void)
{
unsigned int longVar =1 ;

while(longVar < 0xffffffff) longVar++;
}



void* threadFunction(void *arg)
{

	ThreadArgs*	myThreadArg;
	myThreadArg = (ThreadArgs*)arg;

	if (main_sched_str != NULL) {
	if (!get_policy(main_sched_str[0], &policy))
		usage(argv[0], "Bad policy for main thread (-m)\n");
		param.sched_priority = strtol(&main_sched_str[1], NULL, 0);
		s = pthread_setschedparam(pthread_self(), policy, &param);
		if (s != 0)
		handle_error_en(s, "pthread_setschedparam");
	}

	g_ThreadMutex[pthread_self()] = PTHREAD_MUTEX_INITIALIZER;
	g_conditionVar[pthread_self().] = PTHREAD_COND_INITIALIZER;


	pthread_mutex_lock ( &g_ThreadMutex[myThreadArg->threadCount] );
	pthread_cond_wait ( &g_conditionVar[myThreadArg->threadCount], &g_ThreadMutex[myThreadArg->threadCount] ); 
	pthread_mutex_unlock( &g_ThreadMutex[myThreadArg->threadCount] );

/*
2. Use the “pthread_setscheduleparam” API to set the thread policy
3. Init the Condition variable and associated mutex
4. Wait on condition variable
5. Once condition variable is signaled, use the “time” function and the “clock_gettime(CLOCK_REALTIME, &tms)” to get timestamp
6. Call “DoProcess” to run your task
7. Use “time” and “clock_gettime” to find end time.
8. You can repeat steps 6 and 7 a few times if you wish
*/
}

int main (int argc, char *argv[]){
	initglobals();
	int index;
	/* Initialize threads. 

	1.	Call InitGlobals
	2.	Create a number of threads (start with 1 and increase to 9) using “pthread_Create”
	3.	Assign 3 threads to SCHED_OTHER, another 3 to SCHED_FIFO and another 3 to SCHED_RR
	4.	Signal the condition variable
	5.	Call “pthread_join” to wait on the thread
	6.	Display the stats on the threads
*/

	while(threadCount < MAX_THREAD_COUNT){
		...
		if( pthread_create(&(g_ThreadArgs[threadCount].threadId), &threadAttrib, &threadFunction, &g_ThreadArgs[threadCount]) )	
		...
	}

}
}
